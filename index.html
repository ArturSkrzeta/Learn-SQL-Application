	<!DOCTYPE HTML>

<html>
	<head>
		<title>Portfolio Artur Skrzeta</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<section id="header">
				<header>
					<span class="image avatar"><a href="https://arturskrzeta.github.io/"><img src="images/avatar.png" alt="" style="margin-bottom:0px;"/></a></span>
					<h1 id="logo"><a href="https://arturskrzeta.github.io/">Artur Skrzeta</a></h1>
					<p>Data Analyst<br />
					+4 years experience</p>
				</header>
				<nav id="nav">
					<ul>
						<li><a href="#one" class="active">Intro</a></li>
						<li><a href="#two">Features</a></li>
						<li><a href="#three">Demo</a></li>
						<li><a href="#four">Setup</a></li>
						<li><a href="#five">Source Code</a></li>
					</ul>
				</nav>
				<footer>
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/artur-skrz%C4%99ta-010b23187/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
						<li><a href="https://www.instagram.com/arturskrrr/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="https://github.com/ArturSkrzeta" class="icon brands fa-github"><span class="label">Github</span></a></li>
						<li><a href="mailto: arturskrzeta@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li
					</ul>
				</footer>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h2>Learn SQL Application</h2>

										<h3>Intro</h3>

										<p style="text-align: justify;">SQL is the declarative lanuguage which we use to say what we want to get and computer needs to figure out the computation tasks to provide quieried result.
											In this post I put my notes and examples that helps me to understand different aspects of SQL. There is also the application for learning SQL demonstrated in the <a href="#three"><u>Demo</u></a> section and its source code linked below.</p>

										<h5>In this section I describe following concepts:</h5>
										<ul>
											<a href="#index"><li>INDEX</li></a>
											<a href="#view"><li>VIEW</li></a>
											<a href="#distinct"><li>DISTINCT</li></a>
											<a href="#join"><li>JOIN</li></a>
											<a href="#union"><li>UNION</li></a>
											<a href="#except"><li>EXCEPT</li></a>
											<a href="#intersect"><li>INTERSECT</li></a>
											<a href="#order_by"><li>ORDER BY</li></a>
											<a href="#limit"><li>LIMIT</li></a>
											<a href="#top"><li>TOP</li></a>
											<a href="#where"><li>WHERE</li></a>
											<a href="#case"><li>CASE</li></a>
											<a href="#group_by"><li>GROUP BY</li></a>
											<a href="#having"><li>HAVING</li></a>
											<a href="#in"><li>IN</li></a>
										</ul>

										<h5>Terminology and general aspects:</h5>
										<ul>
											<li><b>Primary key</b> - a column or columns combination that idetifies a specific row uniquely. It implies NOT NULL constraint and hast to be UNIQUE.</li>
											<li><b>Foreign key</b> - a column that contains a primary key of a record from another table. This way we build relationship between tables.
												<br><br>
												<table>
												<tr style="background-color: #223639; color: #ffff;">
													<td>
													customers<br>
													- <u>customer_id: <span style="color:#00ffea;">pk</span> integer</u><br>
													- phone: string<br>
													- email: string
													</td>
													<td>
													orders<br>
													- order_id: integer<br>
													- status: string<br>
													- <u>customer_id: <span style="color:#00ffea;">fk</span> integer</u>
													</td>
												</tr>
												</table>
												- In above example pk stands for primary key and fk stands for foreign key.<br>
												- In one to many relationship: one customer can have many orders, so we can find one customer multiple times in the orders table.<br>
												- As per one to many relationship, one order cannot have multiple customers.<br>
												<span style="font-size:14px;">orderd table</span>
												<table style="font-size:16px;">
													<thead>
														<tr>
															<th>order_id</th>
															<th>status</th>
															<th>customer_id</th>
														</tr>
													</thead>
													<tbody>
														<tr>
															<td>1</td>
															<td>completed</td>
															<td>1</td>
														</tr>
														<tr>
															<td>2</td>
															<td>completed</td>
															<td>1</td>
														</tr>
														<tr>
															<td>3</td>
															<td>cancelled</td>
															<td>3</td>
														</tr>
														<tr>
															<td>4</td>
															<td>pending</td>
															<td>1</td>
														</tr>
													</tbody>
												</table>
											</li>
											<li>Db engine executes query in the sequence as below:
												<br>
												1. FROM, JOIN - it determines data table(s).<br>
												2. WHERE - records filtering.<br>
												3. GROUP BY - records grouping.<br>
												4. HAVING  - groups filtering.<br>
												5. SELECT - columns filtering.<br>
												6. ORDER BY - results sorting.<br>
											</li>
											<li>There are different types of SQL queries:
												<br>
												1. <b>DQL</b> - Data Query Language</b>:<br>
												&nbsp&nbsp&nbsp&nbsp&nbsp- <code>SELECT</code>.<br>
												2. <b>DML</b> – Data Manipulation Language:<br>
												&nbsp&nbsp&nbsp&nbsp&nbsp- <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>.<br>
												3. <b>DDL</b> – Data Definition Language:<br>
												&nbsp&nbsp&nbsp&nbsp&nbsp- <code>CREATE</code>, <code>ALTER</code>, <code>DROP</code>, <code>RENAME</code>, <code>TRUNCATE</code>.<br>
												4. <b>DCL</b> – Data Control Language:<br>
												&nbsp&nbsp&nbsp&nbsp&nbsp- <code>GRANT</code>, <code>REVOKE</code>.<br>
												5. <b>TCL</b> - Transaction Control Language:<br>
												&nbsp&nbsp&nbsp&nbsp&nbsp- <code>COMMIT</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code>.<br>
											</li>
											<li><b>Constraints</b> - we put the as the limits on the data types of the table. It can be specified while creating or altering the table statement.
													Here they are:
													<br>
													- NOT NULL prevents from keeping nulls in the column.<br>
													- CHECK limits the value range that can placed in the column for instance:<br>
													 	&nbsp&nbsp&nbspAge INTEGER, CHECK (AGE>=18).<br>
													- DEFAULT provides default value to all records unless other value specified.<br>
													- UNIQUE prevents from storing duplicates within a column.<br>
													- PRIMARY KEY sets pk on a column.<br>
													- FOREIGN KEY sets fk indicating pk of a table in the relationship.<br>
											</li>
											<li><b>Data integrity</b> - defines the accuracy as well as the consistency of the data stored in a database.
													Once data integrity ensured then any addition or deletion of data from the table will not create any mismatch in the relationship of the tables.
											</li>
											<li><b>Stored procedure</b> - saved SQL code so that it can be reused anytime with or without passed parameters:
												<br>
												- stored procedure syntax:
<!-- start -->
<pre>
CREATE PROCEDURE procedure_name
AS
sql_statement
GO;
</pre>
<!-- end -->
												- executing stored procedure:
<!-- start-->
<pre>
EXEC procedure_name
</pre>
<!-- end -->
												- here how it looks like with parameters:
<!-- start -->
<pre>
CREATE PROCEDURE SelectAllEmployees <span style="background-color:#3976b3;">@City nvarchar(30)</span>, <span style="background-color:#3976b3;">@PostalCode nvarchar(10)</span>
AS
SELECT * FROM employees WHERE City = <span style="background-color:#3976b3;">@City</span> AND PostalCode = <span style="background-color:#3976b3;">@PostalCode</span>
GO;
</pre>
<!-- end -->
												- calling it with parameters:
<!-- start -->
<pre>
EXEC SelectAllCustomers <span style="background-color:#3976b3;">@City = 'Cracow'</span>, <span style="background-color:#3976b3;">@PostalCode = '30-708'</span>;
</pre>
<!-- end -->
												- They can be used as a modular programming which means creating once, storing and calling many times whenever it's required.<br>
												- This supports faster overall query performance.
											</li>
										</ul>

										<h5>Database Normalization:</h5>
										<ul>
											<li><b>Normalization</b> is the db designing process where we aim for minimizing any data redundancy.
												Redundancy of data means there are multiple copies of the same information spread over multiple locations in the same database.
											</li>
											<li>There are 3 forms of the normalizaton where each consecutive normal form depends on the previous one:
												<br>
												✓ First normal form (1 NF)<br>
												✓ Second normal form (2 NF)<br>
												✓ Third normal form (3 NF)<br>
												Where db is considered the third normal form if it meets the requirements of the first 3 normal forms.
											</li>
											<li>In <b>1 NF</b> wa aim to keep only atomic information. Here is the example which violates the 1NF as it contains more tan one value for the department column:
												<table>
													<tr>
														<td>id</td>
														<td>name</td>
														<td>salary</td>
														<td>department</td>
													</tr>
													<tr>
														<td>1</td>
														<td>Artur</td>
														<td>3000</td>
														<td>IT, DevOps</td>
													</tr>
													<tr>
														<td>2</td>
														<td>John</td>
														<td>10000</td>
														<td>IT, DevOps, DataLab</td>
													</tr>
												</table>
												- Definitely we should be avoiding creating new columns like department1, department2, department3 what we call repeating groups.<br>
												- In order to reach 1 NF, we need to split the table into two tables:
												<br><br>
												<span>Department table and assignment table</span>
												<table>
													<tr>

														<td>
															<table style="width:20%;">
																<tr>
																	<td>dep_id</td>
																	<td>dep_name</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>IT</td>
																	<td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>DevOps</td>
																</tr>
																<tr>
																	<td>3</td>
																	<td>DataLab</td>
																</tr>
															</table>
														</td>

														<td>
															<table>
																<tr>
																	<td>emp_id</td>
																	<td>name</td>
																	<td>salary</td>
																	<td>dep_id</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>Artur</td>
																	<td>3000</td>
																	<td>1</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>Artur</td>
																	<td>3000</td>
																	<td>2</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>John</td>
																	<td>10000</td>
																	<td>1</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>John</td>
																	<td>10000</td>
																	<td>2</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>John</td>
																	<td>10000</td>
																	<td>3</td>
																</tr>
															</table>
														</td>
													</tr>
												</table>
												- With that solution what we get is many-to-many relationship where many employees can be assigned to one or more departments.
											</li>
											<li>....
												<br><br>
												<span>Employees table and assignment table</span>
												<table>
													<tr>

														<td>
															<table style="width:15%;">
																<tr>
																	<td>emp_id</td>
																	<td>emp_name</td>
																	<td>emp_salary</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>Artur</td>
																	<td>3000</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>John</td>
																	<td>10000</td>
																</tr>
															</table>
														</td>

														<td>
															<table style="width:20%;">
																<tr>
																	<td>emp_id</td>
																	<td>dep_id</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>1</td>
																</tr>
																<tr>
																	<td>1</td>
																	<td>2</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>1</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>2</td>
																</tr>
																<tr>
																	<td>2</td>
																	<td>3</td>
																</tr>
															</table>
														</td>
													</tr>
												</table>

											</li>
											<li>When we care about keeping table normalized we get a set of benefits:
												<br>
												- better db organization,<br>
												- more tables with smaller rows,<br>
												- easy modification,<br>
												- reduction of redundant and duplicate data.<br>
												- ensuring data integrity.
											</li>
											<li><b>Denormaliaztion</b> - combining multiple tables into one for achieving fast data access.</li>
										</ul>

										<h5 id="view">VIEW</h5>
										<ul>
											<li>It's a virtual table based on the result of any SQL statement.</li>
											<li>A view contains all you need in every other table: rows and columns and fields can come from one or more real tables.</li>
											<li>While creating views, we can apply <code>WHERE</code> or <code>JOIN</code> statements to keep the data as if it comes from one single table.</li>
											<li>Here is the syntax for view creating:
<!-- start -->
<pre>
CREATE VIEW <span style="background-color:#ad5353;">view_name</span> AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
</pre>
<!-- end -->
												- end here is how to query a view:
<!-- start -->
<pre>
SELECT * FROM [<span style="background-color:#ad5353;">view_name</span>];
</pre>
<!-- end -->
											</li>
											<li>With views we can restric users from being able to check some confidential data.
													In a view we just define what columns are visible. The columns we want to keep invisible, we don't include them into the view while creating.
													For example, lets say we have the employees table data schema:<br>
													&nbsp&nbsp&nbsp- id: numeric<br>
													&nbsp&nbsp&nbsp- first_name: string<br>
													&nbsp&nbsp&nbsp- last_name: string<br>
													&nbsp&nbsp&nbsp- salary: numeric<br>
													Let's assume that column salary is confidential and has to be restricted from viewing:
<!-- start -->
<pre>
CREATE VIEW <span style="background-color:#ad5353;">emloyess_details</span> AS
SELECT first_name, last_name,
FROM employess
WHERE last_name LIKE 'S%';
</pre>
<!-- end -->
												- When we wat to check salary somehow:
												<!-- start -->
<pre>
SELECT last_name, salary
FROM <span style="background-color:#ad5353;">emloyess_details</span>
WHERE last_name LIKE 'S%';
</pre>
<!-- end -->
												- Querying the view <code>emloyess_details</code> for <code>salary</code> field raises an error.
											</li>
											<li>It aslo simplifies queries hiding their complexity made with UNION, JOIN etc.</li>
										</ul>


										<h5 id="index">INDEX</h5>
										<ul>
											<li>An index is used to speed up searching in the database by reducing records amount to be scanned.</li>
											<li>An index helps to speed up <code>SELECT</code> queries and <code>WHERE</code> clauses, but it slows down data input, with the <code>UPDATE</code> and the <code>INSERT</code> statements.</li>
											<li>Creating an index involves the <code>CREATE INDEX</code> statement, which allows you to name the index, to specify the table and which column or columns to index:
<!-- start -->
<pre>
CREATE INDEX index_name
ON table_name (column_name);
</pre>
<!-- end -->
											</li>
											<li>Updating a table with indexes takes more time than updating a table without (because the indexes also need an update).
													So, only create indexes on columns that will be frequently searched against.
											</li>
											<li>When not to use indexes:
												<br>
												- on small tables,<br>
												- on tables that have frequent, large updates or insert operations,<br>
												- on columns that contain a large number of NULLs,<br>
												- on columns that are frequently manipulated.<br>
											</li>
											<li>Here is how to use it:
												<br>
												- creating index:
<!-- start -->
<pre>
CREATE INDEX employees_last_name_idx
ON employees (<span style="background-color:#3976b3;">last_name</span>);
</pre>
<!-- end -->
												- using indexed column in the select query:
<!-- start -->
<pre>
SELECT *
FROM employees
WHERE salary > 10000 AND
    <span style="background-color:#3976b3;">last_name</span> = "Smith"
</pre>
<!-- end -->
												- we use <code>last_name</code> indexed column wihthin WHERE caluse along with <code>salary</code> which speeds up performing the query.<br>
												- It simply works like an index in the book where a specific sections or chapters ar indexed with their headings.
											</li>
											<li>We can also index multiple columns, however it takes very long to set it up for the db engine.</li>
											<li>We can say that there are two types of indexes:
												<br>
												<table>
													<thead>
														<tr>
															<td>Clustered Index</td>
															<td>Non-Clustered Index</td>
														</tr>
													</thead>
													<tbody>
														<tr>
															<td>Defines the order of storing data in the table</td>
															<td>Doesn't define the order of data inside the table</td>
														</tr>
														<tr>
															<td>As data always can be stored in one way, there can be only one clustered index. When creating a table, the primary key constraint automatically creates index on that column.</td>
															<td>In fact, non-clustered index is stored at different place than table data is stored. This allows for more than one non-clustered index per table.</td>
														</tr>
														<tr>
															<td>Clustered indexes only sort tables. Therefore, they do not consume extra storage.</td>
															<td>Non-clustered indexes are stored in a separate place from the actual table claiming more storage space.</td>
														</tr>
														<tr>
															<td>Fast performance.</td>
															<td>Slower performance as it requires additional lookup between index sotrage and acutal table.</td>
														</tr>
													</tbody>
												</table>
												- It is important to mention here that inside the table the data will be sorted by a clustered index.<br>
												- However, inside the non-clustered index data is stored in the specified order.<br>
												- The non-clustered index contains column values on which the index is created and the address of the corresponding records in the actual table.
											</li>
											<li>Here is how it works:
													<br>
													- When a query is run against indexed column, the database will first go to the index and look for the address of the corresponding row in the table.
												 	It will then go to that row address in the table and fetch other column values.
											</li>
										</ul>

										<p id="namespace" style="font-size:22px; border-bottom: 1px solid #cacaca; padding-bottom:10px; padding-top:50px;"><b>SELECT</b></p>

										<h5 id="distinct">DISTINCT</h5>
										<ul>
											<li>Using when we wan to get unique values from a given column.
<!-- start -->
<pre>
SELECT DISTINCT name
FROM students
</pre>
<!-- end -->
											</li>
										</ul>

										<h5 id="join">JOIN</h5>
										<ul>
											<li>Join is the keyword needed when quering more than one table.</li>
											<li>While joining, we need to define on what columns (of both tables) we will be keeping tables joined.</li>
											<li>Usually, we use primary key of one table matching it with its corresponding foreign key in another table.</li>
											<li>There are a few kind of joins:
												<br>
												- <b>Left join</b>: returns all the rows from the left table regardless if there is a match or a null from the right table.<br>
												- <b>Right join</b>: returns all the rows from the right table regardless if there is a match or a null from the left table.<br>
												- <b>Inner join</b>: returns rows when there is a match in rows between the tables.<br>
												- <b>Full outer join</b>: returns all the rows from the left-hand side table and all the rows from the right-hand side table.<br>
											</li>
											<li>Let's take two table schemas for an example:
												<br><br>
												<table>
												<tr style="background-color: #223639; color: #ffff; font-size:18px;">
													<td>
													tblVideo<br>
													- video_id: PRIMARY KEY integer<br>
													- author_id: integer<br>
													- video_duration: float
													</td>
													<td>
													tblView<br>
													- video_id: FOREIGN KEY integer<br>
													- viewer_id: integer<br>
													- viewer_timewatch: float
													</td>
												</tr>
												</table>
											</li>
											<li>Inner join example:
												<br>
												<i><b>How many publishers have at least one viewer?</b></i>
<!-- start -->
<pre>
SELECT COUNT(DISTINCT vd.author_id)
FROM tblVideo vd
INNER JOIN tblView vw
ON vd.video_id = vw.video_id
</pre>
<!-- end -->
													- It doesn't count authors whose videos are not in the tblView.<br>
													- If I want to count disctinct author's id, I wouldn't need any JOINs and do select only on tblVideo.
											</li>
											<li id="order_by">Left join example:
												<br>
												- Here is the snippet of data schema:
												<br>
												<img src="images/sql_server.JPG" width="420"><span style="font-size:12px">source: toptal.com</span>
<!-- strat -->
<pre>
SELECT i.Id, i.BillingDate, c.Name, r.Name AS ReferredByName
FROM Invoices i
 LEFT JOIN Customers c ON i.CustomerId = c.Id
 LEFT JOIN Customers r ON c.ReferredBy = r.Id
ORDER BY i.BillingDate ASC;
</pre>
<!-- end -->
												- With LEFT JOIN we make sure that all the invoices will be returned no matter what (in case of any NULLs within Customers table).<br>
												- First LEFT JOIN joins customer id pk with customer id fk in the Invoices table.<br>
												- Second LEFT JOIN joins customer id pk with cusotmer id  fk in the Customer table.<br>
												- ORDER BY orders outcome by date. We can append ASC/DESC if ascending or descending ordering.
											</li>
											<li>We can join multiple tables:
<!-- start -->
<pre>
SELECT column1, column2
FROM TableA
JOIN TableB ON TableA.Column3 = TableB.Column3
JOIN TableC ON TableA.Column4 = TableC.Column4
</pre>
<!-- stop -->
											</li>
										</ul>

										<h5 id="union">UNION</h5>
										<ul>
											<li>Merges the contents of two structurally-compatible tables into a single combined table removing duplicated records.</li>
											<li>There is also UNION ALL that does the same things but keeps duplicated records.</li>
											<li>Performance of UNION ALL is better than UNION, since UNION requires the server to do the additional work of removing any duplicate.</li>
											<li>Here is how to use it:
<!-- start -->
<pre>
SELECT employee_id, first_name, last_name, 'Employee' AS status
FROM employees
UNION
SELECT visitor_id, first_name, last_name, 'Visitor' AS status
FROM visitors
</pre>
<!-- stop -->
												- note that colums selected from both tables have to be in sync with each other.
											</li>
										</ul>

										<h5 id="except">EXCEPT</h5>
										<ul>
											<li>Allows to fetch values from one table that are not in another table.
<!-- start -->
<pre>
CREATE TABLE test_a(id INTEGER);
INSERT INTO test_a(id) VALUES (10);
INSERT INTO test_a(id) VALUES (20);
INSERT INTO test_a(id) VALUES (30);
INSERT INTO test_a(id) VALUES (40);
INSERT INTO test_a(id) VALUES (50);

CREATE TABLE test_b(id INTEGER);
INSERT INTO test_b(id) VALUES (10);
INSERT INTO test_b(id) VALUES (30);
INSERT INTO test_b(id) VALUES (50);

SELECT * FROM test_a
EXCEPT
SELECT * FROM test_b;

----------------------
20, 40
</pre>
<!-- end -->
												- 20 and 40 are the values that are not present in test_b table.
											</li>
										</ul>

										<h5 id="intersect">INTERSECT</h5>
										<ul>
											<li>Fetchs common records between two tables:
<!-- start -->
<pre>
SELECT * FROM EmployeeSalary
INTERSECT
SELECT * FROM ManagerSalary;
</pre>
<!-- end -->
											</li>
										</ul>

										<h5 id="limit">LIMIT</h5>
										<ul>
											<li>Limiting select query results to specific numbers of records:
<!-- start -->
<pre>
SELECT *
FROM (
	SELECT *
	FROM employees
	ORDER BY salary DESC )
LIMIT 10;
</pre>
<!-- end -->
												- We fetch 10 highest salaries in employees tabel.<br>
												- We use subquery meaning we emebd one select into another.
											</li>
										</ul>

										<h5 id="top">TOP</h5>
										<ul>
											<li>We can select x top records:
												<br>
												- let's assume we have customers table and the fields customer_id,<br>
												- let's fetch first 100 odd cutomer_id values,<br>
												- <span id="where">there, we use WHERE clause to filter fetch rows, this clause allows AND as well as OR operators,</span>
<!-- start -->
<pre>
SELECT TOP 100 customer_id
FROM customers
WHERE customer_id % 2 = 1
ORDER BY user_id
</pre>
<!-- end -->
												- Clause Were can also have BETWEEM operator:
<!-- start -->
<pre>
SELECT *
FROM employees
WHERE date_of_joining BETWEEN '2020/01/01' AND '2020/12/31';
</pre>
<!-- end -->
												- When it comes to dates, we can extract what we want:
<!-- start -->
<pre>
SELECT *
FROM employees
WHERE YEAR(date_of_joining) = '2020'
</pre>
<!-- end -->
											</li>
										</ul>

										<h5 id="group_by">GROUP BY</h5>
										<ul>
											<li>Groups rows when they have the same value in the field we indicate:
<!-- start -->
<pre>
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 3;
</pre>
<!-- end -->
												- We count all customers for a specific country but we display countires where count is bigger than 3.<br>
												- We use GROUP BY when some aggregating function in select line like COUNT, SUM, AVERAGE.<br>
												- <span id="having">HAVING simply puts filter on COUNT(CustomerID) outcome column.</span>
<!-- start -->
<pre>
COUNT(CustomerID)	Country
9			Brazil
11			France
11			Germany
5			Mexico
5			Spain
7			UK
13			USA
4			Venezuela
</pre>
<!-- end -->
											</li>
											<li>WHERE vs HAVING:
												<br>
												- When GROUP BY is not used, then WHERE and HAVING clauses works the same.<br>
												- When  GROUP BY is used, then WHERE clause is used to filter records from a result and filtering works before any grouping. HAVING clause is used to filter values from a group.
											</li>
										</ul>


										<h5>Referencing to the same table more than once:</h5>
										<ul>
											<li>Here is the employees table:
												<br><br>
												<table style="font-size:16px;">
													<thead>
														<tr>
															<th>Emp_Id</th>
															<th>Emp_name</th>
															<th>Salary</th>
															<th>Manager_Id</th>
														</tr>
													</thead>
													<tbody>
														<tr>
															<td>10</td>
															<td>Anil</td>
															<td>50000</td>
															<td>18</td>
														</tr>
														<tr>
															<td>11</td>
															<td>Vikas</td>
															<td>75000</td>
															<td>16</td>
														</tr>
														<tr>
															<td>12</td>
															<td>Nisha</td>
															<td>40000</td>
															<td>18</td>
														</tr>
														<tr>
															<td>13</td>
															<td>Nidhi</td>
															<td>60000</td>
															<td>17</td>
														</tr>
														<tr>
															<td>14</td>
															<td>Priya</td>
															<td>80000</td>
															<td>18</td>
														</tr>
														<tr>
															<td>15</td>
															<td>Mohit</td>
															<td>45000</td>
															<td>18</td>
														</tr>
														<tr>
															<td>16</td>
															<td>Rajesh</td>
															<td>90000</td>
															<td>Null</td>
														</tr>
														<tr>
															<td>17</td>
															<td>Raman</td>
															<td>55000</td>
															<td>16</td>
														</tr>
														<tr>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
														</tr>
													</tbody>
												</table>
											</li>
											<li>Lets fetch all rows with WHERE clause on <b>a.manager_id = b.emp_id</b>:
<!-- start -->
<pre>
SELECT *
FROM Employee a, Employee b
WHERE a.manager_id = b.emp_id
</pre>
<!-- end -->
												<table class="employees_query" style="font-size:16px;">
													<tbody>
														<tr>
															<td>10</td>
															<td>Anil</td>
															<td>50000</td>
															<td>18</td>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
														</tr>
														<tr>
															<td>11</td>
															<td>Vikas</td>
															<td>75000</td>
															<td>16</td>
															<td>16</td>
															<td>Rajesh</td>
															<td>90000</td>
															<td>Null</td>
														</tr>
														<tr>
															<td>12</td>
															<td>Nisha</td>
															<td>40000</td>
															<td>18</td>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
														</tr>
														<tr>
															<td>13</td>
															<td>Nidhi</td>
															<td>60000</td>
															<td>17</td>
															<td>17</td>
															<td>Raman</td>
															<td>55000</td>
															<td>16</td>
														</tr>
														<tr>
															<td>14</td>
															<td>Priya</td>
															<td>80000</td>
															<td>18</td>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
														</tr>
														<tr>
															<td>15</td>
															<td>Mohit</td>
															<td>45000</td>
															<td>18</td>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
														</tr>
														<tr>
															<td>17</td>
															<td>Raman</td>
															<td>55000</td>
															<td>16</td>
															<td>16</td>
															<td>Rajesh</td>
															<td>90000</td>
															<td>Null</td>
														</tr>
														<tr>
															<td>18</td>
															<td>Santosh</td>
															<td>65000</td>
															<td>17</td>
															<td>17</td>
															<td>Raman</td>
															<td>55000</td>
															<td>16</td>
														</tr>
													</tbody>
												</table>
												- Note there is no Rajesh in the outcome as he has no manager above him. Rajesh appears only as the manager for other employees.
											</li>
											<li>Let's group managers counting average salary:
<!-- start -->
<pre>
SELECT b.emp_id AS "Manager_Id", b.emp_name AS "Manager", AVG(b.salary) AS "Avg_Salary_Under_Manager"
FROM employees a, employees b
WHERE a.manager_id = b.emp_id
GROUP BY b.emp_id
ORDER BY b.emp_id;
</pre>
<!-- end -->
												<table style="font-size:16px;">
													<tbody>
														<tr>
															<th>Manager_Id</th>
															<th>Manager</th>
															<th>Average_Salary_Under_Manager</th>
														</tr>
														<tr>
															<td>16</td>
															<td>Rajesh</td>
															<td>65000</td>
														</tr>
														<tr>
															<td>17</td>
															<td>Raman</td>
															<td>62500</td>
														</tr>
														<tr>
															<td>18</td>
															<td>Santosh</td>
															<td>53750</td>
														</tr>
													</tbody>
												</table>
											</li>
										</ul>

										<p id="update" style="font-size:22px; border-bottom: 1px solid #cacaca; padding-bottom:10px; padding-top:50px;"><b>UPDATE</b></p>

										<h5 id="case">CASE</h5>
										<ul>
											<li>We can use Case to give some conditons:
												<br>
												- assuming we have tblTest table and Nmbr filed,<br>
												- tblTest has 50 rows and Nmbr field contains 1s and 0s,<br>
												- let's replace 1s with 11s and 0s with 10s:
<!-- start -->
<pre>
UPDATE tblTest SET Nmbr = case
 WHEN Nmbr = 0 THEN 10
 ELSE 11 END;
</pre>
<!-- end -->
											</li>
										</ul>

										<h5 id="in">IN</h5>
										<ul>
											<li>The IN operator allows to specify multiple values in a WHERE clause.</li>
											<li>If taken value 'Apple' is in one of given caolumns then we take rows into results.</li><br>
												<table style="font-size:16px;">
													<tr>
														<td>Id</td>
														<td>Col1</td>
														<td>Col2</td>
														<td>Col3</td>
													</tr>
													<tr>
														<td>1</td>
														<td>Apple</td>
														<td>Null</td>
														<td>Orange</td>
													</tr>
													<tr>
														<td>2</td>
														<td>Orange</td>
														<td>Apple</td>
														<td>Strawberry</td>
													</tr>
													<tr>
														<td>3</td>
														<td>Strawberry</td>
														<td>Apple</td>
														<td>Orange</td>
													</tr>
												</table>
<!-- start -->
<pre>
SELECT * FROM table
WHERE 'Apple' IN (Col1, Col2 Col3)
</pre>
<!-- end -->
											</li>
										</ul>

									</header>
								</div>
							</section>

						<!-- Two -->
							<section id="two">
								<div class="container">
									<h3>Features</h3>
									<p>App includes following features:</p>
									<ul class="feature-icons">
										<li class="icon solid fa-check">SQL</li>
									</ul>
								</div>
							</section>

						<!-- Three -->
							<section id="three">
								<div class="container">
									<h3>Demo</h3>

									<h5>Application:</h5>
									<img src="images/sql_learn.gif">
									<ul>
										<li>User click Get Questions button what pulls questions down to the application.</li>
										<li>Each question and answer is hidden. We can click on the proper links to unhide question.</li>
										<li>User can unhide question first, formulate its answer, then unhide the app's answer in order to comapre.</li>
									</ul>

									<h5>Features:</h5>
									<ul>
										<li>NodeJS - server-side API sevice to handle application's HTTP requests.</li>
										<li>MongoDB Atlas - server connects cloud data storage where I keep question-answer documents that are pulled to application.</li>
										<li>RactJS - front-end.</li>
										<li>ExpressJS - web framework that supports building API interfaces.</li>
									</ul>

								</div>
							</section>

						<!-- Four -->
							<section id="four">
								<div class="container">
									<h3>Setup</h3>
									<h5>No specific installation required.</h5>
									<ul>
										<li>npm</li>
										<li>ReactJs</li>
										<li>ExpressJS</li>
									</ul>
								</div>
							</section>

							<section id="five">
								<div class="container">
									<h3>Source Code</h3>
									<p>You can view the source code: <a href="https://github.com/ArturSkrzeta/Learn-SQL-Application/tree/main/project">HERE</a></p>
									<p>&nbsp</p>
								</div>
							</section>

					</div>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<a href="https://arturskrzeta.github.io/" style="padding-bottom:10px;">Back to Portfolio</a>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
			<script src="assets/js/scrolla.js"></script>
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
